<%
  require 'json'
  require 'securerandom'
  require 'digest/sha1'
  require 'fileutils'
  require 'erb'

  if self.accounts.empty?
    abort('Sorry, you need to provide an account')
  end

  $first_account = JSON.parse(self.accounts.first)
  $second_account = JSON.parse(self.accounts[1])
  $second_user = $second_account['username'].to_s
  $second_password = $second_account['password'].to_s

  $main_user = $first_account['username'].to_s
  $main_user_pass = $first_account['password'].to_s

  $server_ip = self.server_ip.first
  $root_password = self.root_password
  $flags = self.flags

  REQUIRED_FLAGS = 3
  while $flags.length < REQUIRED_FLAGS
    $flags << "flag{#{SecureRandom.hex}}"
    Print.err "Warning: Not enough flags provided to hackerbot_config generator, some flags won't be tracked/marked!"
  end


  def get_binding
    binding
  end
%>
<?xml version="1.0"?>

<hackerbot
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.github/cliffe/SecGen/hackerbot">
<!--<hackerbot xmlns="http://www.github/cliffe/SecGen/hackerbotz"-->

	<name>Hackerbot</name>

	<AIML_chatbot_rules>config/AIML</AIML_chatbot_rules>

	<!--Method for gaining shell access, can be overwritten per-attack-->
  <get_shell>sshpass -p <%= $root_password %> ssh -oStrictHostKeyChecking=no root@{{chat_ip_address}} /bin/bash</get_shell>

	<messages>
		<show_attack_numbers />

		<greeting>Hi there. Today I'm your boss of sorts. I need you to config the security of your desktop. Help out and I'll give you some flags.</greeting>

		<!--Must provide alternatives for each message-->
		<say_ready>When you are ready, simply say 'ready'.</say_ready>
		<say_ready>'Ready'?</say_ready>
		<next>Ok, I'll do what I can to move things along...</next>
		<next>Moving things along to the next one...</next>
		<previous>Ok, I'll do what I can to back things up...</previous>
		<previous>Ok, backing up.</previous>
		<goto>Ok, skipping it along.</goto>
		<goto>Let me see what I can do to goto that attack.</goto>
		<last_attack>That was the last one for now. You can rest easy, until next time... (End.)</last_attack>
		<last_attack>That was the last one. Game over?</last_attack>
		<first_attack>You are back to the beginning!</first_attack>
		<first_attack>This is where it all began.</first_attack>
		<getting_shell>Doing my thing...</getting_shell>
		<getting_shell>Here we go...</getting_shell>
		<got_shell>...</got_shell>
		<got_shell>....</got_shell>
		<repeat>Let me know when you are 'ready', if you want to move on say 'next', or 'previous' and I'll move things along.</repeat>
		<repeat>Say 'ready', 'next', or 'previous'.</repeat>

		<!--Single responses:-->
		<help>I am waiting for you to say 'ready', 'next', 'previous', 'list', 'goto *X*', or 'answer *X*'</help>
		<say_answer>Say "The answer is X".</say_answer>
		<no_quiz>There is no question to answer</no_quiz>
		<correct_answer>Correct</correct_answer>
		<incorrect_answer>Incorrect</incorrect_answer>
		<invalid>That's not possible.</invalid>
		<non_answer>Wouldn't you like to know.</non_answer>

		<!--can be overwritten per-attack-->
		<shell_fail_message>Oh no. Failed to get shell... You need to let us in. Hint: you may need to disable libpam-abl or clear the blacklist.</shell_fail_message>
	</messages>

	<tutorial_info>
		<title>Authentication</title>
		<tutorial><%= ERB.new(File.read self.templates_path + 'intro.md.erb').result(self.get_binding) %></tutorial>
		<footer>
<%= File.read self.templates_path + 'resources.md.erb' %>

<%= File.read self.templates_path + 'license.md.erb' %>

Randomised instance generated by [SecGen](http://github.com/cliffe/SecGen)
		</footer>

		<provide_tutorial>true</provide_tutorial>

	</tutorial_info>


	<attack>
		<prompt>Configure your desktop so that passwords are required to be at least 10 characters long.</prompt>
    <post_command>echo -e '8Ch@r!12\n8Ch@r!12' | passwd <%= $second_user %> ; echo -$?-</post_command>

    <condition>
			<output_matches>password is shorter than 10</output_matches>
      <message>:) Well done! <%= $flags.pop %></message>
      <trigger_next_attack />
		</condition>
    <condition>
			<output_matches>updated successfully</output_matches>
      <message>:( I set a short password. Did you forgot to add a password quality rule?</message>
		</condition>
		<else_condition>
      <message>:( Something was not right</message>
		</else_condition>

	</attack>


	<attack>
		<prompt>Configure your desktop so that passwords must include at least 3 character classes when length is between 8-12 characters using pam_passwdqc.</prompt>
    <post_command>echo -e 'j9s2i3m4\nj9s2i3m4\nj9s2i3m4\nj9s2i3m4' | passwd <%= $second_user %> ; echo "p1-$?-"; echo -e 'K9$mPlex!2\nK9$mPlex!2\nK9$mPlex!2\nK9$mPlex!2' | passwd <%= $second_user %> ; echo "p2-$?-";</post_command>

		<condition>
			<output_matches>p1-0-</output_matches>
      <message>:( I set a password with only 2 character classes. Check your pam_passwdqc configuration.</message>
		</condition>
    <condition>
			<output_matches>p2-0-</output_matches>
      <message>:) Well done! <%= $flags.pop %></message>
      <trigger_next_attack />
		</condition>
		<else_condition>
      <message>:( Something was not right with the password rules</message>
		</else_condition>

	</attack>


	<!-- TODO: This is not working as expected, due to TTY issues -->
	<!-- <attack>
		<prompt>Configure faillock to lock accounts for 5 minutes after 2 failed login attempt.</prompt>
    <post_command>
      yes "wrongpass" | su -c "whoami" <%= $second_user %>; 
      yes "wrongpass" | su -c "whoami" <%= $second_user %>;
      faillock - -user <%= $second_user %> 2>&1 | grep -E "(locked|Error reading tally directory)"
    </post_command>

    <condition>
      <output_matches>Error reading tally directory</output_matches>
      <message>:( The failures are not being logged. Make sure you have configured PAM to use faillock.</message>
    </condition>
    <condition>
			<output_matches>locked</output_matches>
      <message>:) Well done! < %= $flags.pop %></message>
      <trigger_next_attack />
		</condition>
		<else_condition>
      <message>:( Account not locked after failed attempt. Check your faillock configuration.</message>
		</else_condition>

	</attack> 
  -->


	<attack>
    <%
      # Generate random time window
      days = ['Mo', 'Tu', 'We', 'Th', 'Fr']
      selected_days = days.sample(2).sort_by { |d| days.index(d) }  # Sort by position in week
      
      start_hour = rand(9..15)  # Random start hour between 9am and 3pm
      duration = rand(2..4)     # Random 2-4 hour window
      end_hour = start_hour + duration
      
      # Format as 4-digit time (e.g., "0900")
      start_time = format('%02d00', start_hour)
      end_time = format('%02d00', end_hour)
      
      # Create different valid day formats
      days_standard = selected_days.join(',')    # e.g., "Mo,Tu"
      if selected_days.map{|d| days.index(d)}.each_cons(2).all?{|a,b| b == a + 1}
        days_range = "#{selected_days.first}-#{selected_days.last}"  # e.g., "Mo-Tu" (only if consecutive)
      else
        days_range = days_standard
      end
    %>
		<prompt>Set up time-based access control to only allow the user <%= $second_user %> to login between <%= start_hour %>:00 and <%= end_hour %>:00 on <%= selected_days.join(' and ') %>. Use a single line new rule.</prompt>
    <post_command>
      grep -qE "^[^;]*;([^;]|\||\!)*;<%=$second_user%>;.*((<%=start_time%>-<%=end_time%>\s*(<%=days_standard%>|<%=days_range%>))|(<%=days_standard%>|<%=days_range%>)\s*<%=start_time%>-<%=end_time%>|(<%=selected_days.join('|')%>)\s*<%=start_time%>-<%=end_time%>)" /etc/security/time.conf;
      echo "p0-$?-";
      grep -q "account.*required.*pam_time.so" /etc/pam.d/common-account;
      echo "p1-$?-"
    </post_command>

    <condition>
			<output_matches>p0-1-</output_matches>
      <message>:( Time-based access control not configured correctly in /etc/security/time.conf</message>
		</condition>
    <condition>
			<output_matches>p1-1-</output_matches>
      <message>:( Time-based access control not configured correctly in /etc/pam.d/common-account</message>
		</condition>
    <condition>
      <output_matches>p0-0-</output_matches>
      <message>:) Well done! <%= $flags.pop %></message>
      <trigger_next_attack />
    </condition>
    <else_condition>
      <message>:( Time-based access control not configured correctly. Check:
      1. PAM is configured to use time-based access control
      2. The time.conf has an entry for user <%= $second_user %>
      3. The rule allows access only during specified hours (<%= start_hour %>:00-<%= end_hour %>:00) on <%= selected_days.join(' and ') %></message>
    </else_condition>

	</attack>

<!-- TODO: This could be a problem if we lock HB out of the machine
	<attack>
		<prompt>Configure libpam-abl to block IPs after 1 failed login attempt for 30 minutes.</prompt>
    <post_command>
      ssh -o ConnectTimeout=5 nonexistent@localhost 2>&1; ablconfig | grep "currently blacklisted"
    </post_command>

    <condition>
			<output_matches>currently blacklisted</output_matches>
      <message>:) Well done! < %= $flags.pop %></message>
      <trigger_next_attack />
		</condition>
		<else_condition>
      <message>:( Automated blacklisting not configured correctly</message>
		</else_condition>

	</attack> -->


</hackerbot>
